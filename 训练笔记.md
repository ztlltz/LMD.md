# 共解决：32题

## 3/15 : 12
### div 4 F. Yet Another Problem About Pairs Satisfying an Inequality  

>前缀和处理一下满足条件的数，倒序查找  
### div 4 G. Good Key, Bad Key  

>注意到后用第二种钥匙总是比先用好，前缀和处理一下后，枚举使用第二种钥匙的节点，考虑到数字小于1e18,故只用往节点后枚举32个数。

>如果倒序算会因为除法导致一些很crazy的结果 

### div 4 A. Spell Check  

>求字符串是不是给定字符串的排列，只需要看和给定字符串的字母种类和数量是不是一样就行了

### div 4 B. Colourblindness  

>给定两个字符串，其中认为某些字符是一样（如认为'g'和'r'一样）的，问这两个字符串在这种意义上是否一样，直接把字符串换成同一种，比较即可

### div 4 C. Word Game  

>求字符串出现了几次，map保存一下

### div 4 D. Line

>给定一个由L和R组成的字符串，定义每个字符的贡献为他左或者右的字符数量（由她是L或者R决定），问能不能修改字符串让总贡献最大

>双指针看两头，左改成R右边改成L

### div 4 E. Counting Rectangles

>给定n个矩形，然后q次询问，问满足边长在一个范围内的矩形的贡献是多少
>
>考虑用一个二维数组表示长宽为n，m的矩形是否存在（类似book数组的用法）,然后用前缀和处理一下，就可以o（1）的求某个范围的矩形有多少个

``` c++
前缀和公式：  num[i][j]+=num[i-1][j]+num[i][j-1]-num[i-1][j-1];
给定a,b,c,d: ans=num[c][d]-num[c][b-1]-num[a-1][d]+num[a-1][b-1];
```
### div 4 F. L-shapes

><img width="516" alt="image" src="https://github.com/ztlltz/LMD.md/assets/104620738/f585877c-40a6-43f2-a753-35a25ab4ff97">

>问是否给定的二维图形满足以上要求

>dfs搜索，关键在于如何判断他是一个L形的,考虑到一个点后就枚举他的两个邻格，如果都是黑色就是L形

### div 4 G. Even-Odd XOR

>问怎么构造长为n的偶次项的异或和与奇次项的异或和相等的数列，且每个数不同

>发现如果满足题目条件，等价于数列的异或和为0，考虑直接1-n-2顺序填入数，n-1比n-2大一个数量级，这样n和n-1一定和前n-2个数不一样，此时只用考虑n和n-1不一样

>发现只有前n-2个数的异或和为0才有这种可能，所以只需要在前n-2个数异或和为0时改一个数，即可（因为改了一个数后异或和一定会改变）

### div 3 A. Escalator Conversations

>给定n个数，和m-1个数，问是否第n个数和前n-1个数的差的绝对值等于后m-1个数，并求满足的个数

>map存一下后者，循环一次即可

### div 3 B. Parity Sort

>给定一个数组，你可以任意交换值奇偶性一样的项，问最后能不能让他有序

>考虑将数组排序，然后看是不是每一项的奇偶性一样，如果一样就可以

### div 3 C. Tiles Comeback

><img width="217" alt="image" src="https://github.com/ztlltz/LMD.md/assets/104620738/4f350cee-4175-4858-9d10-eaa9aeb9629e">

>给定一个数组和一个k，每次能走任意长度，问能不能每次都走k次数字一样格子后换一个数字，最后到终点

>考虑只要起点和终点的数字满足即可，跑一个l和r，如果l<r就行，如果起点和终点数字一样，就只需要l和r存在就行
--- 
## 3/16 ：10题

### div 3 A. Thorns and Coins

>给定一个数组，其中有一些点不能到达，还有一些点上有贡献，问如果一次只能走两步或者一步，那么最多可以走多少个有贡献的格子

>考虑如果可以走一步就走一步，否则两步或者停止

### div 3 B. Chaya Calendar

>总而言之就是求离现在最近的下一个ai的倍数

### div 3 C. LR-remainders

>给定一个数组，和一个字符串，每次根据字符串的字符删除数组最左边或者最右边的数，求剩下元素的乘积是多少

>考虑直接看最后一个剩下的数是谁，然后从他开始倒着处理字符串，一直往两边乘即可

### div 3 D. Card Game

>给定4种花色的卡片，其中一种比其他花色都大，剩下的只能和本花色的比大小，问能不能构造一个两两有序的序列

>看能不能用最大的花色给其他花色的牌的数量补成偶数

### div 3 E. Final Countdown

>给定一个非常长的数字字符串n，问如果这个数字变成0，所有位数上一共有多少次数字的变化

>考虑第i位上的数字会变化n/(1ei-1)次，比如500的5会变化5次（4，3，2，1，0），对表达式化简，可以转化为求前缀和后的大整数加法

### div 3 F. Feed Cats

>给定一些线段的左端点和右端点，在某个点，你可以选择到所有区间包含这个点的线段，问你如果每个线段最多只能被选到一次，最多能选到多少个线段

>考虑dp[i]表示到1-i点最多选多少个线段，dp[i]=max(dp[i-1],dp[l-1]-1+cur)

>其中l表示到i点时还剩余的所有线段的最左侧的端点,cur表示剩余线段的数量
 
### div 3 G. Moving Platforms

>有n个点，m条边，每个点有个初始权值，这个权值每秒会变化，但是对h同余，问从1到n最短要多少时间

>考虑单源最短路，唯一的难点是计算路的权值，最后发现可以化为ax+by=c的形式，使用exgcd计算即可

```c++
int exgcd(int a,int b,int &x,int &y){
    if(b==0){
    x=1;
    y=0;
    return a;
    }
    int p=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return p;
}
//其中x的最小值为x mod b/gcd , 还要判断c mod gcd 是否为0，否则不成立
```
