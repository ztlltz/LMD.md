# 共解决：60题

## 3/15 : 12
### div 4 F. Yet Another Problem About Pairs Satisfying an Inequality  

>前缀和处理一下满足条件的数，倒序查找  
### div 4 G. Good Key, Bad Key  

>注意到后用第二种钥匙总是比先用好，前缀和处理一下后，枚举使用第二种钥匙的节点，考虑到数字小于1e18,故只用往节点后枚举32个数。

>如果倒序算会因为除法导致一些很crazy的结果 

### div 4 A. Spell Check  

>求字符串是不是给定字符串的排列，只需要看和给定字符串的字母种类和数量是不是一样就行了

### div 4 B. Colourblindness  

>给定两个字符串，其中认为某些字符是一样（如认为'g'和'r'一样）的，问这两个字符串在这种意义上是否一样，直接把字符串换成同一种，比较即可

### div 4 C. Word Game  

>求字符串出现了几次，map保存一下

### div 4 D. Line

>给定一个由L和R组成的字符串，定义每个字符的贡献为他左或者右的字符数量（由她是L或者R决定），问能不能修改字符串让总贡献最大

>双指针看两头，左改成R右边改成L

### div 4 E. Counting Rectangles

>给定n个矩形，然后q次询问，问满足边长在一个范围内的矩形的贡献是多少
>
>考虑用一个二维数组表示长宽为n，m的矩形是否存在（类似book数组的用法）,然后用前缀和处理一下，就可以o（1）的求某个范围的矩形有多少个

``` c++
前缀和公式：  num[i][j]+=num[i-1][j]+num[i][j-1]-num[i-1][j-1];
给定a,b,c,d: ans=num[c][d]-num[c][b-1]-num[a-1][d]+num[a-1][b-1];
```
### div 4 F. L-shapes

><img width="516" alt="image" src="https://github.com/ztlltz/LMD.md/assets/104620738/f585877c-40a6-43f2-a753-35a25ab4ff97">

>问是否给定的二维图形满足以上要求

>dfs搜索，关键在于如何判断他是一个L形的,考虑到一个点后就枚举他的两个邻格，如果都是黑色就是L形

### div 4 G. Even-Odd XOR

>问怎么构造长为n的偶次项的异或和与奇次项的异或和相等的数列，且每个数不同

>发现如果满足题目条件，等价于数列的异或和为0，考虑直接1-n-2顺序填入数，n-1比n-2大一个数量级，这样n和n-1一定和前n-2个数不一样，此时只用考虑n和n-1不一样

>发现只有前n-2个数的异或和为0才有这种可能，所以只需要在前n-2个数异或和为0时改一个数，即可（因为改了一个数后异或和一定会改变）

### div 3 A. Escalator Conversations

>给定n个数，和m-1个数，问是否第n个数和前n-1个数的差的绝对值等于后m-1个数，并求满足的个数

>map存一下后者，循环一次即可

### div 3 B. Parity Sort

>给定一个数组，你可以任意交换值奇偶性一样的项，问最后能不能让他有序

>考虑将数组排序，然后看是不是每一项的奇偶性一样，如果一样就可以

### div 3 C. Tiles Comeback

><img width="217" alt="image" src="https://github.com/ztlltz/LMD.md/assets/104620738/4f350cee-4175-4858-9d10-eaa9aeb9629e">

>给定一个数组和一个k，每次能走任意长度，问能不能每次都走k次数字一样格子后换一个数字，最后到终点

>考虑只要起点和终点的数字满足即可，跑一个l和r，如果l<r就行，如果起点和终点数字一样，就只需要l和r存在就行
--- 




## 3/16 ：10题

### div 3 A. Thorns and Coins

>给定一个数组，其中有一些点不能到达，还有一些点上有贡献，问如果一次只能走两步或者一步，那么最多可以走多少个有贡献的格子

>考虑如果可以走一步就走一步，否则两步或者停止

### div 3 B. Chaya Calendar

>总而言之就是求离现在最近的下一个ai的倍数

### div 3 C. LR-remainders

>给定一个数组，和一个字符串，每次根据字符串的字符删除数组最左边或者最右边的数，求剩下元素的乘积是多少

>考虑直接看最后一个剩下的数是谁，然后从他开始倒着处理字符串，一直往两边乘即可

### div 3 D. Card Game

>给定4种花色的卡片，其中一种比其他花色都大，剩下的只能和本花色的比大小，问能不能构造一个两两有序的序列

>看能不能用最大的花色给其他花色的牌的数量补成偶数

### div 3 E. Final Countdown

>给定一个非常长的数字字符串n，问如果这个数字变成0，所有位数上一共有多少次数字的变化

>考虑第i位上的数字会变化n/(1ei-1)次，比如500的5会变化5次（4，3，2，1，0），对表达式化简，可以转化为求前缀和后的大整数加法

### div 3 F. Feed Cats

>给定一些线段的左端点和右端点，在某个点，你可以选择到所有区间包含这个点的线段，问你如果每个线段最多只能被选到一次，最多能选到多少个线段

>考虑dp[i]表示到1-i点最多选多少个线段，dp[i]=max(dp[i-1],dp[l-1]-1+cur)

>其中l表示到i点时还剩余的所有线段的最左侧的端点,cur表示剩余线段的数量

### 天梯赛 L2-001 紧急救援

>给定一个图，其中节点上有权值，问怎么可以到达目标节点花费最短并且得到的权值较大，并保存路线

>考虑使用单源最短路，如果距离不变但是权值变大就更新，保存路线用一个数组记录当前点是从哪来的，最后递归的输出。

### 天梯赛 L2-002 链表去重

>给定一个链表，希望将值重复的节点单拉出来成为一个新的链表

>map看重复，然后两个数组保存链表

### 天梯赛 L2-003 月饼

>可以把物品分割的背包问题

>直接按单价排序，模拟

### 天梯赛 L2-004 这是二叉搜索树吗？

>给定一个二叉树的前序遍历，问原树有没有可能是二叉搜索树或者其镜像，如果是，输出后序遍历

>考虑二叉搜索树的前序遍历分三个部分，本身，左子树（比他小的），右子树（比他大的），所以可以递归的搜索左右子树，如果不能恰好把区间分为两个部分，就说明不是或者是镜像，考虑是镜像再进行递归如果还不是就说明不是二者之一，否则后续遍历出结果







## 3/17 ：10

### 天梯赛 L2-005 集合相似度

>给定n个集合，q次询问，每次问两个集合的不相同元素的个数除以总数的值

>unodered_set秒了

 
### div 3 G. Moving Platforms

>有n个点，m条边，每个点有个初始权值，这个权值每秒会变化，但是对h同余，问从1到n最短要多少时间

>考虑单源最短路，唯一的难点是计算路的权值，最后发现可以化为ax+by=c的形式，使用exgcd计算即可

```c++
int exgcd(int a,int b,int &x,int &y){
    if(b==0){
    x=1;
    y=0;
    return a;
    }
    int p=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return p;
}
//其中x的最小值为x mod b/gcd , 还要判断c mod gcd 是否为0，否则不成立
```

### div 3 A. Make it White

>给定一个仅有WB组成的字符串，问最左端和最右端的B之间长度

### div 3 B. Following the String

>给定一个数组，其中ai的含义是字符串s的i左边和当前字符相同的字符的数量，问能不能重构这个字符串

>考虑每次能用字典序小的字符就用小的否则往后用，开一个长为n的数组，考虑下一次出现某个数量，应该用哪个字符

### div 3 C. Choose the Different Ones!

>给定两个数组，和一个k，问能不能从每个数组中取k/2个数，恰好让1到k的每一个数都有

>先看一下两个数组中有没有1到k的所有数，然后看1到k的数是不是每一个都大于等于k/2，如果是就可以

###  div 3 D. Find the Different Ones!

>给定一个数组和q次查询，每次查询问l到r区间内的数有没有不相同的，如果有就输出任意一对

>记录每个数离他最近的一个不同的数，然后看l会不会比r的最近不同数远，如果是就不行，否则输出下标是r的数和它最近的数

### div 3 E. Klever Permutation

>像让你构造一个全排列，其中每相邻k个元素的和相同，输出任意一种排列

><img width="189" alt="image" src="https://github.com/ztlltz/LMD.md/assets/104620738/eaab6161-d597-47f2-aa11-287a6d8db7a8">

>谜底写在谜面上，构造形如值变化为+-+-+-的序列即可

### div 4 A. Short Sort

>给定一个字符串：abc，和一个abc的排列，问有没有可能通过交换一次排列的任意两个字符，让排列和abc相同

>只要有一个字符和abc相同就行

### div 4 B. Good Kid

>给定最多10个数字，可以让你给任意一个数字+1一次，问所有数最大的乘积是多少

>妈的跟他爆了

### div 4 C.Target Practice

><img width="301" alt="image" src="https://github.com/ztlltz/LMD.md/assets/104620738/cdf73a72-90f7-4321-a931-03f99df3349b">  
>
>总而言之就是问你一个点在哪个区块

>发现一个点的区块是min(x,y,11-x,11-y); //下标从1开始
>
>不是我发现的（

## 3/18：10

### div 4 D.1D Eraser

>给定一个仅由W和B组成的字符串，你每次可以让连续的k个字符全部变成W,问最少要进行多少次操作可以让字符串为全W

>考虑每次处理最左边的字符，然后往后跳到+k的位置

### div 4 E. Building an Aquarium

><img width="294" alt="image" src="https://github.com/ztlltz/LMD.md/assets/104620738/362c6e15-6119-416e-8546-72ad86158749">  

>给定一个数组，其下标的含义是一个高度，现在想在水池的两边加一个高度为h的墙，使得里面的空隙的体积不超过一个给定的w,问墙最大高度是多少

>考虑二分答案
```c++
while(l<r){
 ll mid=(l+r+1)/2;
 if(judge(mid)){
 l=mid;
 }
 else{
 r=mid-1;
 }
}
```

### div 4 F. Money Trees

>给定a,b两个数组，想选择最长的l到r使得任意的l<i<r,都有a[i+1]%a[i]==0并且sum（bl-br）小于等于k

>考虑从头开始往外双指针

### div 2 B. Yet Another Coin Problem

>给定一个数，问用1.3.6.10.15这几个数，最少用多少个数可以凑到给定的数
>
>发现对于1.3.6.10的任意一个数的使用次数不会超过它后面那个数的值，直接暴力枚举前几个数的使用次数，判断能不能凑出来，如果能，选择数最少的方案

### div 4 G. ABBC or BACB

>给一个只由AB组成的字符串，把BA修改成CB可以获得一个贡献，把AB修改成BC可以获得一个贡献，问贡献最大是多少

>考虑形如B...B..的可以把所有A都得到一个贡献,而...BB...的也可以,唯独...B...B...B..必须要舍弃一个区间，故舍弃A数量最少的那个区间
