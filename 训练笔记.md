# 共解决：250题

## 3/15 : 12
### div 4 F. Yet Another Problem About Pairs Satisfying an Inequality  

>前缀和处理一下满足条件的数，倒序查找  
### div 4 G. Good Key, Bad Key  

>注意到后用第二种钥匙总是比先用好，前缀和处理一下后，枚举使用第二种钥匙的节点，考虑到数字小于1e18,故只用往节点后枚举32个数。

>如果倒序算会因为除法导致一些很crazy的结果 

### div 4 A. Spell Check  

>求字符串是不是给定字符串的排列，只需要看和给定字符串的字母种类和数量是不是一样就行了

### div 4 B. Colourblindness  

>给定两个字符串，其中认为某些字符是一样（如认为'g'和'r'一样）的，问这两个字符串在这种意义上是否一样，直接把字符串换成同一种，比较即可

### div 4 C. Word Game  

>求字符串出现了几次，map保存一下

### div 4 D. Line

>给定一个由L和R组成的字符串，定义每个字符的贡献为他左或者右的字符数量（由她是L或者R决定），问能不能修改字符串让总贡献最大

>双指针看两头，左改成R右边改成L

### div 4 E. Counting Rectangles

>给定n个矩形，然后q次询问，问满足边长在一个范围内的矩形的贡献是多少
>
>考虑用一个二维数组表示长宽为n，m的矩形是否存在（类似book数组的用法）,然后用前缀和处理一下，就可以o（1）的求某个范围的矩形有多少个

``` c++
前缀和公式：  num[i][j]+=num[i-1][j]+num[i][j-1]-num[i-1][j-1];
给定a,b,c,d: ans=num[c][d]-num[c][b-1]-num[a-1][d]+num[a-1][b-1];
```
### div 4 F. L-shapes

><img width="516" alt="image" src="https://github.com/ztlltz/LMD.md/assets/104620738/f585877c-40a6-43f2-a753-35a25ab4ff97">

>问是否给定的二维图形满足以上要求

>dfs搜索，关键在于如何判断他是一个L形的,考虑到一个点后就枚举他的两个邻格，如果都是黑色就是L形

### div 4 G. Even-Odd XOR

>问怎么构造长为n的偶次项的异或和与奇次项的异或和相等的数列，且每个数不同

>发现如果满足题目条件，等价于数列的异或和为0，考虑直接1-n-2顺序填入数，n-1比n-2大一个数量级，这样n和n-1一定和前n-2个数不一样，此时只用考虑n和n-1不一样

>发现只有前n-2个数的异或和为0才有这种可能，所以只需要在前n-2个数异或和为0时改一个数，即可（因为改了一个数后异或和一定会改变）

### div 3 A. Escalator Conversations

>给定n个数，和m-1个数，问是否第n个数和前n-1个数的差的绝对值等于后m-1个数，并求满足的个数

>map存一下后者，循环一次即可

### div 3 B. Parity Sort

>给定一个数组，你可以任意交换值奇偶性一样的项，问最后能不能让他有序

>考虑将数组排序，然后看是不是每一项的奇偶性一样，如果一样就可以

### div 3 C. Tiles Comeback

><img width="217" alt="image" src="https://github.com/ztlltz/LMD.md/assets/104620738/4f350cee-4175-4858-9d10-eaa9aeb9629e">

>给定一个数组和一个k，每次能走任意长度，问能不能每次都走k次数字一样格子后换一个数字，最后到终点

>考虑只要起点和终点的数字满足即可，跑一个l和r，如果l<r就行，如果起点和终点数字一样，就只需要l和r存在就行
--- 




## 3/16 ：10题

### div 3 A. Thorns and Coins

>给定一个数组，其中有一些点不能到达，还有一些点上有贡献，问如果一次只能走两步或者一步，那么最多可以走多少个有贡献的格子

>考虑如果可以走一步就走一步，否则两步或者停止

### div 3 B. Chaya Calendar

>总而言之就是求离现在最近的下一个ai的倍数

### div 3 C. LR-remainders

>给定一个数组，和一个字符串，每次根据字符串的字符删除数组最左边或者最右边的数，求剩下元素的乘积是多少

>考虑直接看最后一个剩下的数是谁，然后从他开始倒着处理字符串，一直往两边乘即可

### div 3 D. Card Game

>给定4种花色的卡片，其中一种比其他花色都大，剩下的只能和本花色的比大小，问能不能构造一个两两有序的序列

>看能不能用最大的花色给其他花色的牌的数量补成偶数

### div 3 E. Final Countdown

>给定一个非常长的数字字符串n，问如果这个数字变成0，所有位数上一共有多少次数字的变化

>考虑第i位上的数字会变化n/(1ei-1)次，比如500的5会变化5次（4，3，2，1，0），对表达式化简，可以转化为求前缀和后的大整数加法

### div 3 F. Feed Cats

>给定一些线段的左端点和右端点，在某个点，你可以选择到所有区间包含这个点的线段，问你如果每个线段最多只能被选到一次，最多能选到多少个线段

>考虑dp[i]表示到1-i点最多选多少个线段，dp[i]=max(dp[i-1],dp[l-1]-1+cur)

>其中l表示到i点时还剩余的所有线段的最左侧的端点,cur表示剩余线段的数量

### 天梯赛 L2-001 紧急救援

>给定一个图，其中节点上有权值，问怎么可以到达目标节点花费最短并且得到的权值较大，并保存路线

>考虑使用单源最短路，如果距离不变但是权值变大就更新，保存路线用一个数组记录当前点是从哪来的，最后递归的输出。

### 天梯赛 L2-002 链表去重

>给定一个链表，希望将值重复的节点单拉出来成为一个新的链表

>map看重复，然后两个数组保存链表

### 天梯赛 L2-003 月饼

>可以把物品分割的背包问题

>直接按单价排序，模拟

### 天梯赛 L2-004 这是二叉搜索树吗？

>给定一个二叉树的前序遍历，问原树有没有可能是二叉搜索树或者其镜像，如果是，输出后序遍历

>考虑二叉搜索树的前序遍历分三个部分，本身，左子树（比他小的），右子树（比他大的），所以可以递归的搜索左右子树，如果不能恰好把区间分为两个部分，就说明不是或者是镜像，考虑是镜像再进行递归如果还不是就说明不是二者之一，否则后续遍历出结果







## 3/17 ：10

### 天梯赛 L2-005 集合相似度

>给定n个集合，q次询问，每次问两个集合的不相同元素的个数除以总数的值

>unodered_set秒了

 
### div 3 G. Moving Platforms

>有n个点，m条边，每个点有个初始权值，这个权值每秒会变化，但是对h同余，问从1到n最短要多少时间

>考虑单源最短路，唯一的难点是计算路的权值，最后发现可以化为ax+by=c的形式，使用exgcd计算即可

```c++
int exgcd(int a,int b,int &x,int &y){
    if(b==0){
    x=1;
    y=0;
    return a;
    }
    int p=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return p;
}
//其中x的最小值为x mod b/gcd , 还要判断c mod gcd 是否为0，否则不成立
```

### div 3 A. Make it White

>给定一个仅有WB组成的字符串，问最左端和最右端的B之间长度

### div 3 B. Following the String

>给定一个数组，其中ai的含义是字符串s的i左边和当前字符相同的字符的数量，问能不能重构这个字符串

>考虑每次能用字典序小的字符就用小的否则往后用，开一个长为n的数组，考虑下一次出现某个数量，应该用哪个字符

### div 3 C. Choose the Different Ones!

>给定两个数组，和一个k，问能不能从每个数组中取k/2个数，恰好让1到k的每一个数都有

>先看一下两个数组中有没有1到k的所有数，然后看1到k的数是不是每一个都大于等于k/2，如果是就可以

###  div 3 D. Find the Different Ones!

>给定一个数组和q次查询，每次查询问l到r区间内的数有没有不相同的，如果有就输出任意一对

>记录每个数离他最近的一个不同的数，然后看l会不会比r的最近不同数远，如果是就不行，否则输出下标是r的数和它最近的数

### div 3 E. Klever Permutation

>像让你构造一个全排列，其中每相邻k个元素的和相同，输出任意一种排列

><img width="189" alt="image" src="https://github.com/ztlltz/LMD.md/assets/104620738/eaab6161-d597-47f2-aa11-287a6d8db7a8">

>谜底写在谜面上，构造形如值变化为+-+-+-的序列即可

### div 4 A. Short Sort

>给定一个字符串：abc，和一个abc的排列，问有没有可能通过交换一次排列的任意两个字符，让排列和abc相同

>只要有一个字符和abc相同就行

### div 4 B. Good Kid

>给定最多10个数字，可以让你给任意一个数字+1一次，问所有数最大的乘积是多少

>妈的跟他爆了

### div 4 C.Target Practice

><img width="301" alt="image" src="https://github.com/ztlltz/LMD.md/assets/104620738/cdf73a72-90f7-4321-a931-03f99df3349b">  
>
>总而言之就是问你一个点在哪个区块

>发现一个点的区块是min(x,y,11-x,11-y); //下标从1开始
>
>不是我发现的（

## 3/18：10

### div 4 D.1D Eraser

>给定一个仅由W和B组成的字符串，你每次可以让连续的k个字符全部变成W,问最少要进行多少次操作可以让字符串为全W

>考虑每次处理最左边的字符，然后往后跳到+k的位置

### div 4 E. Building an Aquarium

><img width="294" alt="image" src="https://github.com/ztlltz/LMD.md/assets/104620738/362c6e15-6119-416e-8546-72ad86158749">  

>给定一个数组，其下标的含义是一个高度，现在想在水池的两边加一个高度为h的墙，使得里面的空隙的体积不超过一个给定的w,问墙最大高度是多少

>考虑二分答案
```c++
while(l<r){
 ll mid=(l+r+1)/2;
 if(judge(mid)){
 l=mid;
 }
 else{
 r=mid-1;
 }
}
```

### div 4 F. Money Trees

>给定a,b两个数组，想选择最长的l到r使得任意的l<i<r,都有a[i+1]%a[i]==0并且sum（bl-br）小于等于k

>考虑从头开始往外双指针

### div 2 B. Yet Another Coin Problem

>给定一个数，问用1.3.6.10.15这几个数，最少用多少个数可以凑到给定的数
>
>发现对于1.3.6.10的任意一个数的使用次数不会超过它后面那个数的值，直接暴力枚举前几个数的使用次数，判断能不能凑出来，如果能，选择数最少的方案

### div 4 G. ABBC or BACB

>给一个只由AB组成的字符串，把BA修改成CB可以获得一个贡献，把AB修改成BC可以获得一个贡献，问贡献最大是多少

>考虑形如B...B..的可以把所有A都得到一个贡献,而...BB...的也可以,唯独...B...B...B..必须要舍弃一个区间，故舍弃A数量最少的那个区间

## 3/21 ：10

### div 4 C. Most Similar Words

>给定n（n<50)个字符串，定义两个字符串之间的距离为所有字符的距离之和，而字符的距离是指该位置上的字母改为上一个或下一个字母d次后与另一个字符串上的字符相同，问距离最小是多少

>直接枚举任意两个字符串的距离，求最小

### div4 D. X-Sum

>给定一个n,m(n<200,m<200)的图，上面有一些点位上有贡献，有一个可以获得对角线上所有贡献的道具，问在哪使用它得到最大贡献

>妈的再和它爆了！

### div 4 E. Eating Queries

>给定一个数组，和q次查询，每次问最少取多少个数可以让他们的和比给定的数大

>排序，前缀和，二分

### div 4 F. Longest Strike

>给定一个长度为 n 的数组 a 和一个整数 k ，要求找出任意两个数 l 和 r 使得l到r的所有数在数组中出现的次数都大于k次，并极大化r-l

>排序数组，然后双指针找最长区间

### div 4 G. White-Black Balanced Subtrees

>给了一颗树，每个节点有个值（0或1），定义一个子树上如果0和1的个数相等，就可以获得一点贡献，问这棵树的贡献是多少

>进行一个很狠的搜索

### div 3 A. Odd Divisor

>给定一个数，问它有没有大于1的奇数因数

>只要不是2的n次方的数就都有

### div 3 B. New Year's Number

>给定一个数，问它能不能通过2020和2021的任意次相加构成

>先预处理范围内所有可以被这两个构成的，然后O(1)的回答

### div 3 C. Ball in Berland

>给定k个不重复的二元组，问选2个不重复的二元组有几种可能，其中两个二元组不重复指的是每个数只能在一元中出现一次

>定义g(x)为以x开头的二元组的个数，f（X）为以x结尾的二元组的个数,对于某一二元组（x,y），他的贡献是 remain-g(x)-f(x)+1，然后让remain-1

### think-cell Round 1 B. Permutation Printing

>给定一个n，问能不能找到一个n的排列，使得不存在任意的i和j，aj可以被ai整除,aj+1可以被ai+1整除

>直接倒序输出1-n

### good-bye 2023 B. Two Divisors

>给定两个数n,m，如果n和m是某个数的最大因数和次大因数，求这个数是多少

>如果n%m==0,答案就是n*n/m
>
>否则就是n*m/gcd(n,m)

## 3/25

### C. Alternating Subsequence

>给定一个序列,求最长的交替子序列，如果长度一样，返回和最大的一个序列
>
>其中，交替子序列的含义是，相邻两项的符号相反

>考虑把连续的相同符号的数只保留最大的那一个一个，然后剩下的全选

### B. Kuriyama Mirai's Stones

>给定一个序列，有两种问法，一是给定l和r问l到r的前缀和，二是求第l小到第r小的前缀和

>前缀和，排序后前缀和

### A. Odd Selection

>给定一个数组，和一个数x，想选x个数，使得和为奇数，问可不可以

>如果和为奇数，那么肯定选了奇数个奇数和任意个偶数，直接枚举选择的奇数个数，看看能不能一共选到x个数

### B. A Balanced Problemset?

>给定一个数x，想把x分解成n个数,使得gcd最大

>考虑gcd一定是x的因数，从小到大直接枚举x的因数，然后看乘n会不会小于x，如果可以就更新答案

### C. Number of Ways

>给定一个数组，想求把数组分为和相同的连续三段的方法数

>先求前缀和，然后枚举第一个节点，二分找第二个节点

### A. Rudolph and Cut the Rope

>说有这么个东西，问要剪掉哪些绳子才能让糖果掉下来（指越过地平线）
>
><img width="133" alt="image" src="https://github.com/ztlltz/LMD.md/assets/104620738/920c1871-33d8-441e-9a4c-ca05ff9cf4b4">

>只要不是自然状态会在地平线以下的都要剪掉

### C. Ternary XOR

>有一个只包含012三个数字的数，已知他是由两个同类型的数通过“按位相加mod3”运算变过来的,假设这两个数是a和b，问max(a,b)的最小值是多少

>第一次把大的给a，其他时候把小的给a，让a尽量小

### B. Ternary String //写笔记时想错了

>给定一个只包含123的字符串，现在想选择一个子串，使得包含123三种字符，且长度最短

>从左到右遍历字符串，每次更新123三种字符最后出现的位置，看以i结尾的字符串的最短满足要求的字符串的长度是多少，然后更新答案

### A. DZY Loves Chessboard

>给定一个字符二维数组，由.和-组成，现在想在.格中填入B或者W，输出一种可能的填法，让B相邻的格子没有W，W周围没有B

>考虑每行都是bW或者Wb的循环，遇到-就跳过

### C. Boats Competition

>给定n个数，现在想规定一个数x，使得把n个数分成二元组后，他们的和与x相同，且极大化这个组数，问x应该是多少
>
>n<=50，且数字小于50

>直接求n个数所有和的可能，然后对每一个判断有多少组可以满足

### A. XXXXX

>给定一个数组，相求最长的子数组，使得子数组不能被x整除

>前缀和对x取模，每次找最远的可能

### C. Challenging Cliffs

>给定一个数组，重新排列数组，使得a(n)-a(0)的绝对值极小化，并使得数组中满足a(i+1)>a(i)的组数最多

>排序数组，找到相差最小的两个数，小的放前面，大的放后面，然后把比较大的数更大的数放在前面，比较小的数小的数放后面
>
><img width="50" alt="image" src="https://github.com/ztlltz/LMD.md/assets/104620738/da740726-fffc-4651-8e71-a55c987f18d1">

# 错题

###  B. Petr and a Combination Lock

#### 大致题意： 

<img width="499" alt="image" src="https://github.com/ztlltz/LMD.md/assets/104620738/df1cd9a4-de08-40c0-953c-a10a9cf54a4f">  

给定一个仪表盘和一个数组，其中数组中的数表示一个角度，问能否通过规定每个角度是顺时针还是逆时针转动，来让指针最后指向原点

#### 错题原因

dp跑错了，多跑了一个循环

#### 题目解决方法

对于每一个数，看他顺时针和逆时针能到哪，最后看最后一个数能不能到原点

