# 共解决：22题

## 3/15 : 12
### div 4 F. Yet Another Problem About Pairs Satisfying an Inequality  

>前缀和处理一下满足条件的数，倒序查找  
### div 4 G. Good Key, Bad Key  

>注意到后用第二种钥匙总是比先用好，前缀和处理一下后，枚举使用第二种钥匙的节点，考虑到数字小于1e18,故只用往节点后枚举32个数。

>如果倒序算会因为除法导致一些很crazy的结果 

### div 4 A. Spell Check  

>求字符串是不是给定字符串的排列，只需要看和给定字符串的字母种类和数量是不是一样就行了

### div 4 B. Colourblindness  

>给定两个字符串，其中认为某些字符是一样（如认为'g'和'r'一样）的，问这两个字符串在这种意义上是否一样，直接把字符串换成同一种，比较即可

### div 4 C. Word Game  

>求字符串出现了几次，map保存一下

### div 4 D. Line

>给定一个由L和R组成的字符串，定义每个字符的贡献为他左或者右的字符数量（由她是L或者R决定），问能不能修改字符串让总贡献最大

>双指针看两头，左改成R右边改成L

### div 4 E. Counting Rectangles

>给定n个矩形，然后q次询问，问满足边长在一个范围内的矩形的贡献是多少
>
>考虑用一个二维数组表示长宽为n，m的矩形是否存在（类似book数组的用法）,然后用前缀和处理一下，就可以o（1）的求某个范围的矩形有多少个

``` c++
前缀和公式：  num[i][j]+=num[i-1][j]+num[i][j-1]-num[i-1][j-1];
给定a,b,c,d: ans=num[c][d]-num[c][b-1]-num[a-1][d]+num[a-1][b-1];
```
### div 4 F. L-shapes

><img width="516" alt="image" src="https://github.com/ztlltz/LMD.md/assets/104620738/f585877c-40a6-43f2-a753-35a25ab4ff97">

>问是否给定的二维图形满足以上要求

>dfs搜索，关键在于如何判断他是一个L形的,考虑到一个点后就枚举他的两个邻格，如果都是黑色就是L形

### div 4 G. Even-Odd XOR

>问怎么构造长为n的偶次项的异或和与奇次项的异或和相等的数列，且每个数不同

>发现如果满足题目条件，等价于数列的异或和为0，考虑直接1-n-2顺序填入数，n-1比n-2大一个数量级，这样n和n-1一定和前n-2个数不一样，此时只用考虑n和n-1不一样

>发现只有前n-2个数的异或和为0才有这种可能，所以只需要在前n-2个数异或和为0时改一个数，即可（因为改了一个数后异或和一定会改变）

### div 3 A. Escalator Conversations

>给定n个数，和m-1个数，问是否第n个数和前n-1个数的差的绝对值等于后m-1个数，并求满足的个数

>map存一下后者，循环一次即可

### div 3 B. Parity Sort

>给定一个数组，你可以任意交换值奇偶性一样的项，问最后能不能让他有序

>考虑将数组排序，然后看是不是每一项的奇偶性一样，如果一样就可以

### div 3 C. Tiles Comeback

><img width="217" alt="image" src="https://github.com/ztlltz/LMD.md/assets/104620738/4f350cee-4175-4858-9d10-eaa9aeb9629e">
>给定一个数组和一个k，每次能走任意长度，问能不能每次都走k次数字一样格子后换一个数字，最后到终点

>考虑只要起点和终点的数字满足即可，跑一个l和r，如果l<r就行，如果起点和终点数字一样，就只需要l和r存在就行
--- 
